package org.borium.javarecompiler.classfile;

import static org.borium.javarecompiler.classfile.ClassFile.*;

import java.util.*;

import org.borium.javarecompiler.classfile.attribute.*;
import org.borium.javarecompiler.classfile.constants.*;

/**
 * Each field is described by a field_info structure. No two fields in one class
 * file may have the same name and descriptor (4.3.2).
 * <p>
 * The structure has the following format:
 *
 * <pre>
	field_info
	{
		u2 access_flags;
		u2 name_index;
		u2 descriptor_index;
		u2 attributes_count;
		attribute_info attributes[attributes_count];
	}
 * </pre>
 */
public class ClassField
{
	public static final int AccessPublic = 0x0001;

	public static final int AccessPrivate = 0x0002;

	public static final int AccessProtected = 0x0004;

	public static final int AccessStatic = 0x0008;

	public static final int AccessFinal = 0x0010;

	public static final int AccessVolatile = 0x0040;

	public static final int AccessTransient = 0x0080;

	public static final int AccessSynthetic = 0x1000;

	public static final int AccessEnum = 0x4000;

	/**
	 * The value of the access_flags item is a mask of flags used to denote access
	 * permission to and properties of this field. The interpretation of each flag,
	 * when set, is specified in Table 4.5-A. <table border>
	 * <tr>
	 * <th>Flag Name</th>
	 * <th>Value</th>
	 * <th>Interpretation</th>
	 * </tr>
	 * <tr>
	 * <td>ACC_PUBLIC</td>
	 * <td>0x0001</td>
	 * <td>Declared public; may be accessed from outside its package.
	 * <tr>
	 * <td>ACC_PRIVATE</td>
	 * <td>0x0002</td>
	 * <td>Declared private; accessible only within the defining class and other
	 * classes belonging to the same nest (5.4.4).</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_PROTECTED</td>
	 * <td>0x0004</td>
	 * <td>Declared protected; may be accessed within subclasses.</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_STATIC</td>
	 * <td>0x0008</td>
	 * <td>Declared static.</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_FINAL</td>
	 * <td>0x0010</td>
	 * <td>Declared final; never directly assigned to after object construction (JLS
	 * 17.5).</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_VOLATILE</td>
	 * <td>0x0040</td>
	 * <td>Declared volatile; cannot be cached.</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_TRANSIENT</td>
	 * <td>0x0080</td>
	 * <td>Declared transient; not written or read by a persistent object
	 * manager.</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_SYNTHETIC</td>
	 * <td>0x1000</td>
	 * <td>Declared synthetic; not present in the source code.</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_ENUM</td>
	 * <td>0x4000</td>
	 * <td>Declared as an element of an enum class.</td>
	 * <tr>
	 * </table>
	 * Fields of classes may set any of the flags in Table 4.5-A. However, each
	 * field of a class may have at most one of its ACC_PUBLIC, ACC_PRIVATE, and
	 * ACC_PROTECTED flags set (JLS 8.3.1), and must not have both its ACC_FINAL and
	 * ACC_VOLATILE flags set (JLS 8.3.1.4).
	 * <p>
	 * Fields of interfaces must have their ACC_PUBLIC, ACC_STATIC, and ACC_FINAL
	 * flags set; they may have their ACC_SYNTHETIC flag set and must not have any
	 * of the other flags in Table 4.5-A set (JLS 9.3).
	 * <p>
	 * The ACC_SYNTHETIC flag indicates that this field was generated by a compiler
	 * and does not appear in source code.
	 * <p>
	 * The ACC_ENUM flag indicates that this field is used to hold an element of an
	 * enum class (JLS 8.9).
	 * <p>
	 * All bits of the access_flags item not assigned in Table 4.5-A are reserved
	 * for future use. They should be set to zero in generated class files and
	 * should be ignored by Java Virtual Machine implementations.
	 */
	private int accessFlags;

	/**
	 * The value of the name_index item must be a valid index into the constant_pool
	 * table. The constant_pool entry at that index must be a CONSTANT_Utf8_info
	 * structure (4.4.7) which represents a valid unqualified name denoting a field
	 * (4.2.2).
	 */
	private int nameIndex;

	/**
	 * The value of the descriptor_index item must be a valid index into the
	 * constant_pool table. The constant_pool entry at that index must be a
	 * CONSTANT_Utf8_info structure (4.4.7) which represents a valid field
	 * descriptor (4.3.2).
	 */
	private int descriptorIndex;

	private HashMap<String, ClassAttribute> attributes = new HashMap<>();

	private ArrayList<ClassAttribute> attributeList = new ArrayList<>();

	private String name;

	private String descriptor;

	public void addReferencedClasses(ReferencedClasses referencedClasses)
	{
		referencedClasses.add(getType());
	}

	public void dump(IndentedOutputStream stream)
	{
		stream.println("Field: " + name + " " + descriptor);
		stream.indent(1);

		stream.iprint("Access Flags: ");
		stream.printHex(accessFlags, 4);
		int flags = accessFlags;
		flags = printAccessFlag(stream, flags, AccessEnum, " Enum");
		flags = printAccessFlag(stream, flags, AccessSynthetic, " Synthetic");
		flags = printAccessFlag(stream, flags, AccessTransient, " Transient");
		flags = printAccessFlag(stream, flags, AccessVolatile, " Volatile");
		flags = printAccessFlag(stream, flags, AccessFinal, " Final");
		flags = printAccessFlag(stream, flags, AccessStatic, " Static");
		flags = printAccessFlag(stream, flags, AccessProtected, " Protected");
		flags = printAccessFlag(stream, flags, AccessPrivate, " Private");
		flags = printAccessFlag(stream, flags, AccessPublic, " Public");
		if (flags != 0)
		{
			stream.print(" Invalid ");
			stream.printHex(flags, 4);
		}
		stream.println();

		stream.iprintln("Attributes: " + attributes.size());
		stream.indent(1);
		for (int i = 0; i < attributes.size(); i++)
		{
			stream.iprint(i + ": ");
			ClassAttribute attribute = attributeList.get(i);
			attribute.dump(stream);
		}
		stream.indent(-2);
	}

	public int getAccessFlags()
	{
		return accessFlags;
	}

	public ClassAttribute getAttribute(String attributeName)
	{
		for (ClassAttribute a : attributeList)
		{
			if (a.getName().equals(attributeName))
			{
				return a;
			}
		}
		return null;
	}

	public String getName()
	{
		return name;
	}

	public String getType()
	{
		if (attributes.containsKey("Signature"))
		{
			AttributeSignature sig = (AttributeSignature) attributes.get("Signature");
			return sig.getSignature();
		}
		return descriptor;
	}

	public void read(ByteInputStream in, ConstantPool cp)
	{
		accessFlags = in.u2();
		nameIndex = in.u2();
		name = cp.getString(nameIndex);
		descriptorIndex = in.u2();
		descriptor = cp.getString(descriptorIndex);
		int attributeCount = in.u2();
		for (int i = 0; i < attributeCount; i++)
		{
			ClassAttribute attribute = ClassAttribute.readAttribute(in, cp);
			attributes.put(attribute.getName(), attribute);
			attributeList.add(attribute);
		}
		// TODO validation
	}
}
